<?php
/**
 * LDActiveRecordConditionBehavior class file.
 *
 * @author Louis A. DaPrato <l.daprato@gmail.com>
 * @link https://lou-d.com
 * @copyright 2014 Louis A. DaPrato
 * @license The MIT License (MIT)
 * @since 1.0
 */

/**
 * LDActiveRecordConditionBehavior generates fully quoted, escaped, and parameter bound CDbCriterias based on a CActiveRecord's attribute values.
 * Attribute values can be scalar values or arrays. If the latter correctly parenthesized IN conditions will be generated.
 * 
 * @author Louis DaPrato <l.daprato@gmail.com>
 *
 */
class LDActiveRecordConditionBehavior extends CActiveRecordBehavior
{
	
	const PARAM_PREFIX = ':ldarcb';
	
	/**
	 * @var integer the global counter for anonymous binding parameters.
	 * This counter is used for generating the name for the anonymous parameters.
	 */
	public static $paramCount = 0;
	
	/**
	 * @var string the category that will be used when translating messages generated by this behavior
	 */
	public $tCategory = 'LDActiveRecordConditionBehavior';
	
	/**
	 * Set this property to configure which columns and how those columns should be part of generated condition criterias
	 * Keys should be column names. Values should be arrays with two boolean values set "partialMatch" and "escape".
	 * This property defaults to Null which will cause the configuration to be generated automatically when this behavior is attached to a CActiveRecord.
	 * The default configuration includes all columns defined in the CActiveRecord's table schema with "partialMatch" set false and "escape" set true.
	 * @var array configuration for generating column conditions
	 */
	public $columns;
	
	/**
	 * (non-PHPdoc)
	 * @see CBehavior::attach()
	 */
	public function attach($owner)
	{
		parent::attach($owner);
		if($this->columns === null)
		{
			foreach($owner->getTableSchema()->columns as $col => $config)
			{
				$this->columns[$col] = new LDActiveRecordColumnCondition();
			}
		}
	}
	
	/**
	 * Translates a message using the category specified by the "tCategory" property
	 * 
	 * @param string $message
	 * @param array $params
	 * @param string $source
	 * @param string $language
	 * @see YiiBase::t()
	 */
	protected function t($message, $params = array(), $source = null, $language = null)
	{
		return Yii::t($this->tCategory, $message, $params, $source, $language);
	}
	
	/**
	 * Generates a search criteria for the CActiveRecord owner of this behavior.
	 * 
	 * @param mixed $mergeCriteria the criteria to be merged with. Either an array or CDbCriteria. 
	 * @param string $prefix
	 *        	column prefix (WITHOUT dot ending!). If null, it will be the 
	 *        	table name alias of the active record this behavior is attached to.
	 * @param string $operator How to combine the condition generated by this function with the existing condition of the CDbCriteria owner or merged CDbCriteria
	 * @param boolean $quoteTableName whether to quote the table alias/prefix name
	 * @param array $columns The columns to generate a search criteria with. Defaults to Null meaning use the {@see LDActiveRecordConditionBehavior::$columns} property.
	 * @param boolean $checkEmpty Whether to check if a value is empty or not before including it in the search criteria. If True and {@see LDActiveRecordConditionBehavior::isEmpty()} returns true, the value will not be included in the search criteria
	 * @param boolean $trim Whether to trim the value when checking if it is empty. This parameter is only effective if $checkEmpty is set to true. {@see LDActiveRecordConditionBehavior::isEmpty()} for more details. 
	 * @return CDbCriteria A copy of the CActiveRecord's current CDbCriteria with generated condition and parameters set
	 */
	public function getSearchCriteria($mergeCriteria = array(), $prefix = null, $operator = 'AND', $quoteTableName = true, $columns = null, $checkEmpty = true, $trim = true)
	{
		$owner = $this->getOwner();
		$values = array();
		$multivalues = array();
		if($columns === null)
		{
			$columns = $this->columns;
		}
		foreach(array_keys($columns) as $column)
		{
			$value = $owner->$column;
			if(!($checkEmpty && $this->isEmpty($value, $trim)))
			{
				if(is_array($value))
				{
					$multivalues[$column] = $value;
				}
				else
				{
					$values[$column] = (string)$value;
				}
			}
		}

		return $this->buildSearchCriteria(array_merge($values, self::zip($multivalues)), $mergeCriteria, $prefix, $quoteTableName);
	}
	
	/**
	 * Generates an SQL criteria condition string with bound parameter values. 
	 * This method returns a CDbCriteria instance that is a clone of the current CDbCriteria of the CActiveRecord instance that this behavior is attached to.
	 * The condition property will contain the generated condition string.
	 * The params property will contain the parameterized condition values.
	 * 
	 * @param mixed $values list of key values to be selected within
	 * @param mixed $mergeCriteria the criteria to be merged with. Either an array or CDbCriteria.
	 * @param string $prefix
	 *        	column prefix (WITHOUT dot ending!). If null, it will be the 
	 *        	table name alias of the active record this behavior is attached to.
	 * @param string $operator How to combine the condition generated by this function with the existing condition of the CDbCriteria owner or merged CDbCriteria
	 * @param boolean $quoteTableName whether to quote the table alias/prefix name
	 * @param array $columns The columns to generate a search criteria with. Defaults to Null meaning use the {@see LDActiveRecordConditionBehavior::$columns} property.
	 * @throws CDbException if specified column is not found in given table
	 * @return CDbCriteria CDbCriteria instance clone of the current CDbCriteria of the CActiveRecord instance that this behavior is attached to 
	 * 			with "condition" property set to the condition string generated by this function and the "params" property set to the values bound to the condition generated by this function.
	 */
	public function buildSearchCriteria($values, $mergeCriteria = array(), $prefix = null, $operator = 'AND', $quoteTableName = true, $columns = null) 
	{
		$owner = $this->getOwner();
		$criteria = clone $owner->getDbCriteria();
		$criteria->mergeWith($mergeCriteria);
		if($values === false) // Values is strictly false condition is '0=1'
		{
			$criteria->mergeWith(array('condition' => '0=1'), $operator);
		}
		else if($values === true) // Values is strictly true condition is '1=1'
		{
			$criteria->mergeWith(array('condition' => '1=1'), $operator);
		} 
		else if(is_array($values))
		{
			if($columns === null) // Use default columns configuration
			{
				$columns = $this->columns;
			}
			else if(is_array($columns)) // Ensure columns are instances of 'LDActiveRecordColumnCondition'
			{
				$reflection = new ReflectionClass('LDActiveRecordColumnCondition');
				foreach($columns as $col => &$config)
				{
					if(!is_object($config) || !$reflection->isInstance($config))
					{
						$config = $reflection->newInstanceArgs((array)$config);
					}
				}
			}
			else
			{
				throw new CDbException($this->t('The parameter "$columns" must be null or an array.'));
			}
			
			$table = $owner->getTableSchema();
			
			if($prefix === null) // Set prefix if not set to criteria alias if set or the owner's table alias
			{
				$prefix = $criteria->alias === null ? $owner->getTableAlias() : $criteria->alias;
			}
			
			if($quoteTableName) // Quote table name
			{
				$prefix = $owner->getDbConnection()->quoteTableName($prefix);
			}
			
			$prefix .= '.';
			
			$compositeKeys = array();
			foreach($values as $columnName => &$vals)
			{
				if(is_string($columnName)) 	// Generate a simple key condition
				{
					if(!isset($table->columns[$columnName]))
					{
						throw new CDbException($this->t('Table "{table}" does not have a column named "{column}".', array(
							'{table}' => $table->name,
							'{column}' => $columnName 
						)));
					}
					
					$column = $table->columns[$columnName];

					if($vals === null) // Generate Null value condition
					{
						$criteria->mergeWith(array('condition' => $prefix.$column->rawName.' IS NULL'), $operator);
					}
					else
					{
						$vals = (array)$vals;
						
						if(count($vals) === 1) // Generate single value condition
						{
							$value = reset($vals);
							if($value === null)
							{
								$criteria->mergeWith(array('condition' => $prefix.$column->rawName.' IS NULL'), $operator);
							}
							else if($columns[$columnName]->processCondition($value, $op))
							{
								$paramName = self::getNextParameterName();
								$criteria->mergeWith(array('condition' => $prefix.$column->rawName." $op ".$paramName, 'params' => array($paramName => ($columns[$columnName]->getIsPartialMatching() ? $value : $table->columns[$columnName]->typecast($value)))), $operator);
							}
						} 
						else // Generate multivalued condition
						{
							$params = array();
							foreach($vals as &$value)
							{
								$params[self::getNextParameterName()] = $column->typecast($value);
							}
							
							$criteria->mergeWith(array('condition' => $prefix.$column->rawName.' IN ('.implode(', ', array_keys($params)).')', 'params' => $params), $operator);
						}
					}
				}
				else // Composite key. Ensure the columns exist and save them for a later pass that will generate the composite key conditions.
				{
					foreach($vals as $columnName => &$value) 
					{
						if(!isset($table->columns[$columnName]))
						{
							throw new CDbException ($this->t('Table "{table}" does not have a column named "{column}".', array(
								'{table}' => $table->name,
								'{column}' => $columnName 
							)));
						}
					}
					$compositeKeys[] = $vals;
				}
			}
			
			// Generate composite key conditions
			if(count($compositeKeys) === 1) // Generate single value composite key condition
			{
				$entries = array();
				$params = array();
				foreach($compositeKeys[0] as $columnName => &$value)
				{
					if($value === null)
					{
						$entries[] = $prefix.$table->columns[$columnName]->rawName.' IS NULL';
					}
					else if($columns[$columnName]->processCondition($value, $op))
					{
						$paramName = self::getNextParameterName();
						$params[$paramName] = ($columns[$columnName]->getIsPartialMatching() ? $value : $table->columns[$columnName]->typecast($value));
						$entries[] = $prefix.$table->columns[$columnName]->rawName." $op ".$paramName;
					}
				}
				$criteria->mergeWith(array('condition' => implode(' AND ', $entries), 'params' => $params), $operator);
			}
			else if(count($compositeKeys) > 1) // Generate multivalued composite key condition
			{
				$keyNames = array();
				foreach($compositeKeys[0] as $columnName => &$value)
				{
					$keyNames[] = $prefix.$table->columns[$columnName]->rawName;
				}
				$params = array();
				$vs = array();
				foreach($compositeKeys as &$value)
				{
					$ps = array();
					foreach($value as $columnName => &$v)
					{
						$paramName = self::getNextParameterName();
						$ps[] = $paramName;
						$params[$paramName] = $table->columns[$columnName]->typecast($v);
					}
					$vs[] = '('.implode(', ', $ps).')';
				}
			
				$criteria->mergeWith(array('condition' => '('.implode(', ', $keyNames).') IN ('.implode(', ', $vs).')', 'params' => $params), $operator);
			}
		}
		else
		{
			throw new CException($this->t('The parameter "$values" must be either a boolean or an array.'));
		}
		return $criteria;
	}
	
	/**
	 * Checks if the given value is empty.
	 * A value is considered empty if it is null, an empty array, or the trimmed result is an empty string.
	 * Note that this method is different from PHP empty(). It will return false when the value is 0.
	 *
	 * Note that this method is exactly the same as CValidator's isEmpty except it has been made public
	 *
	 * @param mixed $value the value to be checked
	 * @param boolean $trim whether to perform trimming before checking if the string is empty. Defaults to false.
	 * @return boolean whether the value is empty
	 */
	public function isEmpty($value, $trim = false)
	{
		return $value === null || $value === array() || $value === '' || $trim && is_scalar($value) && trim($value) === '';
	}
	
	/**
	 * Utility function that generates unique parameter names to be used to bind values in SQL criteria.
	 * 
	 * @return string unique SQL parameter name
	 */
	public static function getNextParameterName()
	{
		return self::PARAM_PREFIX.self::$paramCount++;
	}
	
	/**
	 * A utility function to zip together an array of arrays.
	 * If the arrays are not of equal length then only the first n elements will be zipped where n is the length of the shortest array.
	 * 
	 * Input format:
	 * array('key1' => array('v1', 'v2', 'v3', ...), 'key2' => array('v1', 'v2', 'v3', ...), ...)
	 * 
	 * Output format:
	 * array(array('key1' => 'v1', 'key2' => 'v1', ...), array('key1' => 'v2', 'key2' => 'v2', ...), array('key1' => 'v3', 'key2' => 'v3', ...), ...)
	 * 
	 * @param array $values The arrays to be zipped together.
	 * @return array The zipped form of the input array.
	 */
	public static function zip($values)
	{
		if(empty($values))
		{
			return $values;
		}
		$values = array_map(create_function('$value', 'return array_values((array)$value);'), $values); // Ensure all array values are numerically keyed arrays
		$n = array_reduce($values, create_function('$count, $arr', 'return min($count, count($arr));'), -1); // Find the length of the shortest array
		$combinedValues = array();
		foreach($values as $key => $val) // Zip the array values together
		{
			foreach($val as $k => $v)
			{
				$combinedValues[$k][$key] = $v; 
			}
		}
		return $combinedValues;
	}
	
}

class LDActiveRecordColumnCondition
{
	
	const DEFAULT_OPERATION = '=';
	
	const DEFAULT_ESCAPE_CONFIGURATION = array('%' => '\%', '_' => '\_', '\\' => '\\\\');
	
	const NO_PARTIAL_MATCH = 0x0;
	
	const PARTIAL_MATCH_AFTER = 0x01;
	
	const PARTIAL_MATCH_BEFORE = 0x02;
	
	private $_partialMatch;
	
	private $_escape;
	
	/**
	 * Constructs an LDActiveRecordColumnCondition
	 * 
	 * @param mixed $partialMatch boolean or integer
	 * @param mixed $escape boolean or array
	 */
	public function __construct($partialMatch = self::NO_PARTIAL_MATCH, $escape = self::DEFAULT_ESCAPE_CONFIGURATION)
	{
		$this->setPartialMatch($partialMatch);
		$this->setEscape($escape);
	}
	
	/**
	 * Get how the value will be partially matched
	 * 
	 * @return integer
	 */
	public function getPartialMatch()
	{
		return $this->_partialMatch;
	}
	
	/**
	 * Set how to partially match the value in this condition
	 * 
	 * @param mixed $partialMatch boolean or integer
	 */
	public function setPartialMatch($partialMatch)
	{
		if($partialMatch === true)
		{
			$this->_partialMatch = self::PARTIAL_MATCH_AFTER | self::PARTIAL_MATCH_BEFORE;
		}
		else if($partialMatch === false)
		{
			$this->_partialMatch = self::NO_PARTIAL_MATCH;
		}
		else
		{
			$this->_partialMatch = (int)$partialMatch & (self::PARTIAL_MATCH_AFTER | self::PARTIAL_MATCH_BEFORE);
		}
	}
	
	/**
	 * Gets the escape configuration
	 * 
	 * @return array The escape configuration. Empty array if not escaping value.
	 */
	public function getEscape()
	{
		return $this->_escape;
	}
	
	/**
	 * Set how to escape the value for this condition
	 * 
	 * @param mixed $escape boolean or array.
	 */
	public function setEscape($escape)
	{
		if($escape === true)
		{
			$this->_escape = self::DEFAULT_ESCAPE_CONFIGURATION;
		}
		else if($escape === false)
		{
			$this->_escape = array();
		}
		else
		{
			$this->_escape = (array)$escape;
		}
	}
	
	/**
	 * Whether this value should be partially matched for this condition
	 * 
	 * @return boolean
	 */
	public function getIsPartialMatching()
	{
		return $this->partialMatch & (self::PARTIAL_MATCH_AFTER | self::PARTIAL_MATCH_BEFORE);
	}
	
	/**
	 * Whether the value should be escaped for this condition
	 * 
	 * @return boolean
	 */
	public function getIsEscaping()
	{
		return $this->_escape !== array();
	}
	
	/**
	 * Helper function for generating a condition for a column value
	 *
	 * @param mixed $value The value to generate a condition. If this is a string then it can be preceded by <>, <=, >=, <, >, = which will be extracted and used as the operation in the condition genrated by this function.
	 * @param string $op The operation to use for the condition
	 * @return boolean True if the value should be part of the condition. False if the value can be omitted from the condition.
	 */
	public function processCondition(&$value, &$op)
	{
		if(is_string($value) && preg_match('/^(?:\s*(<>|<=|>=|<|>|=))?(.*)$/', $value, $matches)) // Extract operation from value if the value is a string
		{
			$value = $matches[2];
			$op = trim($matches[1]) === '' ? self::DEFAULT_OPERATION : $matches[1]; // If op was empty set to default
		}
		else // Use default op
		{
			$op = self::DEFAULT_OPERATION;
		}
	
		if($this->getIsEscaping()) // If escaping, escape the value
		{
			$this->escape($value);
		}
		
		if($this->getIsPartialMatching()) // If partial matching prepare value and op for a partial match
		{
			return $this->partialMatch($value, $op);
		}
		
		return true;
	}
	
	/**
	 * Escapes a value by casting it to a string then translating it using the current escape configuration
	 * 
	 * @param mixed $value The value to be escaped
	 */
	public function escape(&$value)
	{
		$value = strtr((string)$value, $this->getEscape());
	}
	
	/**
	 * Prepares value and op for partial match.
	 * Cast value to string.
	 * Wrap value with '%' wildcard.
	 * Change op to 'NOT LIKE' or 'LIKE'.
	 * 
	 * @param mixed $value The value to partially match against
	 * @param string $op The operation to perform when matching
	 * @return boolean False if the value can be omitted from the condition. True otherwise.
	 */
	public function partialMatch(&$value, &$op)
	{
		$value = (string)$value;
		if($value === '') // If empty string then this value will not effect the condition. Return false.
		{
			return false;
		}
		
		if($this->partialMatch & self::PARTIAL_MATCH_AFTER) // Prepend '%'
		{
			$value = '%'.$value;
		}
	
		if($this->partialMatch & self::PARTIAL_MATCH_BEFORE) // Append '%'
		{
			$value = $value.'%';
		}
			
		if($op === '<>' || $op === '!=') // If op is a negative comparison change to 'NOT LIKE'
		{
			$op = 'NOT LIKE';
		}
		else // If op is something other than a negative comparison change to 'LIKE'
		{
			$op = 'LIKE';
		}
		return true;
	}
	
}